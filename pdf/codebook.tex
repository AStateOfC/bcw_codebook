\documentclass[10pt,twocolumn,oneside]{article}
\setlength{\columnsep}{10pt}                                                                    %兩欄模式的間距
\setlength{\columnseprule}{0pt}                                                                %兩欄模式間格線粗細

\usepackage{amsthm}								%定義，例題
\usepackage{amssymb}
%\usepackage[margin=2cm]{geometry}
\usepackage{fontspec}								%設定字體
\usepackage{color}
\usepackage[x11names]{xcolor}
\usepackage{xeCJK}								%xeCJK
\usepackage{listings}								%顯示code用的
%\usepackage[Glenn]{fncychap}						%排版，頁面模板
\usepackage{fancyhdr}								%設定頁首頁尾
\usepackage{graphicx}								%Graphic
\usepackage{enumerate}
\usepackage{titlesec}
\usepackage{amsmath}

%\usepackage[T1]{fontenc}
\usepackage{amsmath, courier, listings, fancyhdr, graphicx}
\topmargin=0pt
\headsep=5pt
\textheight=780pt
\footskip=0pt
\voffset=-40pt
\textwidth=520pt
\marginparsep=0pt
\marginparwidth=0pt
\marginparpush=0pt
\oddsidemargin=0pt
\evensidemargin=0pt
\hoffset=-30pt

%\renewcommand\listfigurename{圖目錄}
%\renewcommand\listtablename{表目錄} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setmainfont{Consolas}				%主要字型
\setCJKmainfont{Consolas}			%中文字型
\XeTeXlinebreaklocale "zh"						%中文自動換行
\XeTeXlinebreakskip = 0pt plus 1pt				%設定段落之間的距離
\setcounter{secnumdepth}{3}						%目錄顯示第三層

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{											% Code顯示
language=C++,										% the language of the code
basicstyle=\footnotesize, 						% the size of the fonts that are used for the code
%numbers=left,										% where to put the line-numbers
numberstyle=\footnotesize,						% the size of the fonts that are used for the line-numbers
stepnumber=1,										% the step between two line-numbers. If it's 1, each line  will be numbered
numbersep=5pt,										% how far the line-numbers are from the code
backgroundcolor=\color{white},					% choose the background color. You must add \usepackage{color}
showspaces=false,									% show spaces adding particular underscores
showstringspaces=false,							% underline spaces within strings
showtabs=false,									% show tabs within strings adding particular underscores
frame=false,											% adds a frame around the code
tabsize=2,											% sets default tabsize to 2 spaces
captionpos=b,										% sets the caption-position to bottom
breaklines=true,									% sets automatic line breaking
breakatwhitespace=false,							% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},							% if you want to add a comment within your code
morekeywords={*},									% if you want to add more keywords to the set
keywordstyle=\bfseries\color{Blue1},
commentstyle=\itshape\color{Red4},
stringstyle=\itshape\color{Green4},
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{fancy}
\fancyfoot{}
%\fancyfoot[R]{\includegraphics[width=20pt]{ironwood.jpg}}
\fancyhead[L]{National Taiwan University bcw3Dno7122}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\contentsname}{Contents} 

\scriptsize
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic}
\subsection{.vimrc}


\lstinputlisting{../codes/Basic/vimrc/.vimrc}

\newpage

\subsection{IncreaseStackSize}
\begin{lstlisting}
//stack resize
asm( "mov %0,%%esp\n" ::"g"(mem+10000000) );

//stack resize (linux)
#include <sys/resource.h>
void increase_stack_size() {
	const rlim_t ks = 64*1024*1024;
	struct rlimit rl;
	int res=getrlimit(RLIMIT_STACK, &rl);
	if(res==0){
		if(rl.rlim_cur<ks){
			rl.rlim_cur=ks;
			res=setrlimit(RLIMIT_STACK, &rl);
		}
	}
}
\end{lstlisting}

\subsection{Default Code}
\lstinputlisting{../codes/Basic/Default_Code/Default_Code.cpp}
\newpage

\section{Data Structure}
\subsection{Bigint}
\lstinputlisting{../codes/Data_Structure/Bigint/Bigint.cpp}

\newpage
\subsection{Leftist Heap}

\lstinputlisting{../codes/Data_Structure/Leftist_Heap/Leftist_Heap.cpp}

\subsection{Treap}
\begin{lstlisting}
class Node{
public:
	int pri,num,cnt,lc,rc;
	Node () : pri(-1), num(0), cnt(0), lc(0), rc(0) {}
	Node (int _num){
		pri = (rand()<<15) + rand();
		num = _num;
		cnt = 1;
		lc = rc = 0;
	}
}tree[MX];

int nMem;

int get_rand(){
	return (rand()<<15) + rand();
}
int get_node(){
	tree[nMem] = Node();
	if (nMem >= MX) while(1);
	return nMem++;
}
void upd_node(int rt){
	if (!rt) return ;
	int lc=tree[rt].lc;
	int rc=tree[rt].rc;
	tree[rt].cnt = tree[lc].cnt + tree[rc].cnt + 1;
}
int merge(int a, int b){
	if (!a) return b;
	if (!b) return a;
	int res=0;
	if (tree[a].pri > tree[b].pri){
		res = a; //get_node();
		tree[res] = tree[a];
		tree[res].rc = merge(tree[res].rc,b);
	} else {
		res = b; //get_node();
		tree[res] = tree[b];
		tree[res].lc = merge(a,tree[res].lc);
	}
	upd_node(res);
	return res;
}
pair<int,int> split(int a, int k){
	if (k == 0) return MP(0,a);
	if (k == tree[a].cnt) return MP(a,0);
	int lc=tree[a].lc, rc=tree[a].rc;
	pair<int,int> res;
	int np=a; //get_node();
	//tree[np] = tree[a];
	if (tree[lc].cnt >= k){
		res = split(lc,k);
		tree[np].lc = res._S;
		res._S = np;
	} else {
		res = split(rc,k-tree[lc].cnt-1);
		tree[np].rc = res._F;
		res._F = np;
	}
	upd_node(res._F);
	upd_node(res._S);
	return res;
}
\end{lstlisting}

\section{Graph}

\subsection{Tarjan}
\lstinputlisting{../codes/Graph/Tarjan/Tarjan.cpp}

\subsection{Strongly Connected Components:Kosaraju's Algorithm}
\begin{lstlisting}
class Scc{
public:
	int n,vst[MAXN];
	int nScc,bln[MAXN];
	vector<int> E[MAXN], rE[MAXN], vc;
	void init(int _n){
		n = _n;
		for (int i=0; i<MAXN; i++){
			E[i].clear();
			rE[i].clear();
		}
	}
	void add_edge(int u, int v){
		E[u]._PB(v);
		rE[v]._PB(u);
	}
	void DFS(int u){
		vst[u]=1;
		FOR(it,E[u]){
			if (!vst[*it])
				DFS(*it);
		}
		vc._PB(u);
	}
	void rDFS(int u){
		vst[u] = 1;
		bln[u] = nScc;
		FOR(it,rE[u]){
			if (!vst[*it])
				rDFS(*it);
		}
	}
	void solve(){
		nScc=0;
		vc.clear();
		_SZ(vst);
		for (int i=0; i<n; i++){
			if (!vst[i])
				DFS(i);
		}
		reverse(vc.begin(),vc.end());
		_SZ(vst);
		FOR(it,vc){
			if (!vst[*it]){
				rDFS(*it);
				nScc++;
			}
		}
	}
};
\end{lstlisting}

\subsection{DMST}
\begin{lstlisting}
// --- hanhanW v1.1 ---
#include <cmath>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#define MSET(x, y) memset(x, (y), sizeof(x))
#define REP(x,y,z) for(int x=(y); x<=(z); x++)
#define FORD(x,y,z) for(int x=(y); x>=(z); x--)
#define FLST(x,y,z) for(int x=(y); x; x=z[x])
#define PB push_back
#define SZ size()
#define MP make_pair
#define F first
#define S second

typedef long long LL;
typedef long double LD;
typedef std::pair<int,int> PII;

const int N = 304;
const int INF = 2147483647>>1;

struct Edge{
	int u,v,c;
}eg[N*N];
int n, m, nSpe, nE, rd[N][N], bln[N], vst[N], dis[N], ismrg[N], prev[N];

int DMST(int root){
	MSET(ismrg,0);
	int curW, ww;
	curW=ww=0;
	while (1){
		MSET(prev,-1);
		REP(i,0,nSpe-1) dis[i]=INF;
		REP(i,0,nE-1){
			if (eg[i].v!=eg[i].u && eg[i].v!=root && dis[eg[i].v] > eg[i].c){
				dis[eg[i].v] = eg[i].c;
				prev[eg[i].v] = eg[i].u;
			}
		}
		
		// find cycle
		int sign=1;
		curW=0;
		MSET(bln,-1); MSET(vst, -1);
		REP(i,0,nSpe-1){
			if (ismrg[i]) continue;
			if (prev[i]==-1 && i!=root) return INF;
			if (i!=root) curW += dis[i];
			int s;
			for (s=i; s!=-1 && vst[s]==-1; s=prev[s])
				vst[s]=i;
			
			if (s!=-1 && vst[s]==i){
				sign=0;
				int j=s;
				while (1){
					ismrg[j]=1;
					bln[j]=s;
					ww += dis[j];
					j=prev[j];
					if (j==s) break;
				}
				ismrg[s]=0;
			}
		}
		
		if (sign) break;
		
		// merge
		REP(i,0,nE-1){
			if (bln[eg[i].v]!=-1) eg[i].c -= dis[eg[i].v];
			if (bln[eg[i].u]!=-1) eg[i].u = bln[eg[i].u];
			if (bln[eg[i].v]!=-1) eg[i].v = bln[eg[i].v];
			if (eg[i].u==eg[i].v) eg[i--] = eg[--nE];
		}
	//	system("pause");
	}
	return curW+ww;
}
void solve(){
	REP(i,0,n-1){
		REP(j,0,n-1)
			rd[i][j]=INF;
		rd[i][i]=0;
	}
	REP(i,1,m){
		int u,v,c;
		scanf("%d%d%d",&u,&v,&c);
		rd[u][v]=std::min(rd[u][v],c);
	}
	REP(k,0,n-1)
		REP(i,0,n-1)
			REP(j,0,n-1)
				rd[i][j] = std::min(rd[i][j], rd[i][k]+rd[k][j]);
	nE=0;
	REP(i,0,nSpe-1)
		REP(j,1,nSpe-1)
			if (i!=j && rd[i][j]!=INF){
				eg[nE++]=(Edge){i,j,rd[i][j]};
		//		printf("%d %d %d\n", i, j, rd[i][j]);
			}
	int ans=DMST(0);
	if (ans==INF) puts("sad..");
	else printf("%d\n", ans);
}

int main(){
	while (~scanf("%d%d%d", &n, &m, &nSpe))
		solve();
	return 0;
}
\end{lstlisting}

\section{Flow}
\subsection{ISAP}
\begin{lstlisting}
class Isap{
public:
	class Edge{
	public:
		int v,f,re;
		Edge (){ v=f=re=-1; }
		Edge (int _v, int _f, int _r){
			v = _v;
			f = _f;
			re = _r;
		}
	};
	int n,s,t,h[N],gap[N];
	vector<Edge> E[N];
	void init(int _n, int _s, int _t){
		n = _n;
		s = _s;
		t = _t;
		for (int i=0; i<N; i++)
			E[i].clear();
	}
	void add_edge(int u, int v, int f){
		E[u]._PB(Edge(v,f,E[v].size()));
		E[v]._PB(Edge(u,f,E[u].size()-1));
	}
	int DFS(int u, int nf, int res=0){
		if (u == t) return nf;
		FOR(it,E[u]){
			if (h[u]==h[it->v]+1 && it->f>0){
				int tf = DFS(it->v,min(nf,it->f));
				res += tf;
				nf -= tf;
				it->f -= tf;
				E[it->v][it->re].f += tf;
				if (nf == 0) return res;
			}
		}
		if (nf){
			if (--gap[h[u]] == 0) h[s]=n;
			gap[++h[u]]++;
		}
		return res;
	}
	int flow(int res=0){
		_SZ(h);
		_SZ(gap);
		gap[0] = n;
		while (h[s] < n)
			res += DFS(s,2147483647);
		return res;
	}
}flow;
\end{lstlisting}
\subsection{Bipartite Matching}
\begin{lstlisting}
bool DFS(int u){
	FOR(it,E[u]){
		if (!vst[*it]){
			vst[*it]=1;
			if (match[*it] == -1 || DFS(match[*it])){
				match[*it] = u;
				match[u] = *it;
				return true;
			}
		}
	}
	return false;
}
int DoMatch(int res=0){
	MSET(match,-1);
	for (int i=1; i<=m; i++){
		if (match[i] == -1){
			memset(vst,0,sizeof(vst));
			DFS(i);
		}
	}
	for (int i=1; i<=m; i++)
		if (match[i] != -1) res++;
	return res;
}
\end{lstlisting}


\subsection{SW-Mincut}
\begin{lstlisting}
// --- hanhanW v1.1 ---
#include <cmath>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#define MSET(x, y) memset(x, y, sizeof(x))
#define REP(x,y,z) for(int x=y; x<=z; x++)
#define FORD(x,y,z) for(int x=y; x>=z; x--)
#define PB push_back
#define SZ size()
#define MP make_pair
#define F first
#define S second

typedef long long LL;
typedef long double LD;
typedef std::pair<int,int> PII;

const int N=514;
const int INF=2147483647>>1;

int n, m, del[N], vst[N], wei[N], rd[N][N];

PII sw(){
    MSET(vst,0);
    MSET(wei,0);
    int p1=-1,p2=-1,mx,cur=0;
    while(1){
        mx=-1;
        REP(i,1,n){
            if (!del[i] && !vst[i] && mx<wei[i]){
                cur=i;
                mx=wei[i];
            }
        }
        if (mx==-1) break;
        vst[cur]=1;
        p1=p2;
        p2=cur;
        REP(i,1,n)
            if (!vst[i] && !del[i])
                wei[i]+=rd[cur][i];
    }
    return std::MP(p1,p2);
}
void input(){
    REP(i,1,n){
        del[i]=0;
        REP(j,1,n)
            rd[i][j] = 0;
    }
    REP(i,1,m){
        int u,v,c;
        scanf("%d%d%d",&u,&v,&c);
        ++u; ++v;
        rd[u][v]+=c;
        rd[v][u]+=c;
    }
}
void solve(){
    int ans=INF;
    PII tmp;
    REP(i,1,n-1){
        tmp=sw();
        int x=tmp.F;
        int y=tmp.S;
        if (wei[y] < ans) ans=wei[y];
        del[y]=1;
        REP(j,1,n){
            rd[j][x]+=rd[j][y];
            rd[x][j]+=rd[y][j];
        }
    }
    printf("%d\n", ans);
}

int main(){
    while (~scanf("%d%d", &n, &m)){
        input();
        solve();
    }
    return 0;
}
\end{lstlisting}

\subsection{Maximum Simple Graph Matching}
\lstinputlisting{../codes/Flow/Maximum_Simple_Graph_Matching/Maximum_Simple_Graph_Matching.cpp}

\section{Math}
\subsection{ax+by=gcd}
\lstinputlisting{../codes/Math/ax+by=gcd/ax+by=gcd.cpp}

\subsection{Chinese Remainder}
\begin{lstlisting}
int pfn; // number of distinct prime factors
int pf[MAXNUM]; // prime factor powers
int rem[MAXNUM]; // corresponding remainder
int pm[MAXNUM];
inline void generate_primes() {
	int i,j;
	pnum=1;
	prime[0]=2;
	for(i=3;i<MAXVAL;i+=2) {
		if(nprime[i]) continue;
		prime[pnum++]=i;
		for(j=i*i;j<MAXVAL;j+=i) nprime[j]=1;
	}
}
inline int inverse(int x,int p) {
	int q,tmp,a=x,b=p;
	int a0=1,a1=0,b0=0,b1=1;
	while(b) {
		q=a/b; tmp=b; b=a-b*q; a=tmp;
		tmp=b0; b0=a0-b0*q; a0=tmp;
		tmp=b1; b1=a1-b1*q; a1=tmp;
	}
	return a0;
}
inline void decompose_mod() {
	int i,p,t=mod;
	pfn=0;
	for(i=0;i<pnum&&prime[i]<=t;i++) {
		p=prime[i];
		if(t%p==0) {
			pf[pfn]=1;
			while(t%p==0) {
				t/=p;
				pf[pfn]*=p;
			}
			pfn++;
		}
	}
	if(t>1) pf[pfn++]=t;
}
inline int chinese_remainder() {
	int i,m,s=0;
	for(i=0;i<pfn;i++) {
		m=mod/pf[i];
		pm[i]=(long long)m*inverse(m,pf[i])%mod;
		s=(s+(long long)pm[i]*rem[i])%mod;
	}
	return s;
}
\end{lstlisting}

\subsection{Miller Rabin}
\begin{lstlisting}
long long power(long long x,long long p,long long mod){
	long long s=1,m=x;
	while(p) {
		if(p&1) s=mult(s,m,mod);
		p>>=1;
		m=mult(m,m,mod);
	}
	return s;
}
bool witness(long long a,long long n,long long u,int t){
	long long x=power(a,u,n);
	for(int i=0;i<t;i++) {
		long long nx=mult(x,x,n);
		if(nx==1&&x!=1&&x!=n-1) return 1;
		x=nx;
	}
	return x!=1;
}
bool miller_rabin(long long n,int s=100) {
	// iterate s times of witness on n
	// return 1 if prime, 0 otherwise
	if(n<2) return 0;
	if(!(n&1)) return n==2;
	long long u=n-1;
	int t=0;
	// n-1 = u*2^t
	while(u&1) {
		u>>=1;
		t++;
	}
	while(s--) {
		long long a=randll()%(n-1)+1;
		if(witness(a,n,u,t)) return 0;
	}
	return 1;
}
\end{lstlisting}
\subsection{Mod}
\begin{lstlisting}
/// _fd(a,b)  floor(a/b).
/// _rd(a,m)  a-floor(a/m)*m.
/// _pv(a,m,r) largest x s.t x<=a && x%m == r.
/// _nx(a,m,r) smallest x s.t x>=a && x%m == r.
/// _ct(a,b,m,r) |A| , A = { x : a<=x<=b && x%m == r }.

int _fd(int a,int b){ return a<0?(-~a/b-1):a/b; }
int _rd(int a,int m){ return a-_fd(a,m)*m; }
int _pv(int a,int m,int r)
{
    r=(r%m+m)%m;
    return _fd(a-r,m)*m+r;
}
int _nt(int a,int m,int r)
{
    m=abs(m);
    r=(r%m+m)%m;
    return _fd(a-r-1,m)*m+r+m;
}
int _ct(int a,int b,int m,int r)
{
    m=abs(m);
    a=_nt(a,m,r);
    b=_pv(b,m,r);
    return (a>b)?0:((b-a+m)/m);
}
\end{lstlisting}
\subsection{Primes}
\begin{lstlisting}
/*
* 12721
* 13331
* 14341
* 75577
* 123457
* 222557
* 556679
* 999983
* 1097774749
* 1076767633
* 100102021
* 999997771
* 1001010013
* 1000512343
* 987654361
* 999991231
* 999888733
* 98789101
* 987777733
* 999991921
* 1010101333
* 1010102101
*/
\end{lstlisting}
\section{Geometry}
\subsection{Minimum Covering Circle}
\begin{lstlisting}
const int N = 1000100;

class Coord{
public:
	double x,y;
	Coord () { x=y=0; }
	Coord (double _x, double _y){ x=_x; y=_y; }
	Coord operator - (const Coord &a) const{
		return Coord(x-a.x,y-a.y);
	}
}p[N],cen;

int n,m;
double r2;

double abs2(Coord a){ return a.x*a.x+a.y*a.y; }
double sqr(double a){ return a*a; }
double dis2(Coord a, Coord b){ return sqr(a.x-b.x) + sqr(a.y-b.y); }
double dot(Coord a, Coord b){ return a.x*b.x + a.y*b.y; }
double X(Coord a, Coord b){ return a.x*b.y - a.y*b.x; }

Coord center(Coord p0, Coord p1, Coord p2) {
    double a1=p1.x-p0.x, b1=p1.y-p0.y, c1=(sqr(a1)+sqr(b1))/2;
    double a2=p2.x-p0.x, b2=p2.y-p0.y, c2=(sqr(a2)+sqr(b2))/2;
    double d = a1 * b2 - a2 * b1;
    double x = p0.x + (c1 * b2 - c2 * b1) / d;
    double y = p0.y + (a1 * c2 - a2 * c1) / d;
	return Coord(x,y);
}

int main(int argc, char** argv){
	while (~scanf("%d %d", &n, &m) && n && m){
		for (int i=0; i<m; i++)
			scanf("%lf %lf", &p[i].x, &p[i].y);
		random_shuffle(p,p+m);
		r2=0;
		for (int i=0; i<m; i++){
			if (dis2(cen,p[i]) <= r2) continue;
			cen = p[i];
			r2 = 0;
			for (int j=0; j<i; j++){
				if (dis2(cen,p[j]) <= r2) continue;
				cen = Coord((p[i].x+p[j].x)/2.0, (p[i].y+p[j].y)/2.0);
				r2 = dis2(cen,p[j]);
				for (int k=0; k<j; k++){
					if (dis2(cen,p[k]) <= r2) continue;
					cen = center(p[i],p[j],p[k]);
					r2 = dis2(cen,p[k]);
				}
			}
		}
		printf("%.3f\n", sqrt(r2));
	}
	
	return 0;
}
\end{lstlisting}

\subsection{Intersection of two circles}
\input{../codes/Geometry/Intersection_of_two_circles/Intersection_of_two_circles.tex}

\section{String}
\subsection{Suffix Array}
\lstinputlisting{../codes/Stringology/Suffix_Array/Suffix_Array.cpp}

\subsection{Aho-Corasick Algorithm}
\begin{lstlisting}
class ACautomata{
	public:
	class Node{
		public:
		int cnt,dp;
		Node *go[26], *fail;
		Node (){
			cnt = 0;
			dp = -1;
			memset(go,0,sizeof(go));
			fail = 0;
		}
	};
	
	Node *root, pool[1048576];
	int nMem;

	Node* new_Node(){
		pool[nMem] = Node();
		return &pool[nMem++];
	}
	void init(){
		nMem = 0;
		root = new_Node();
	}
	void add(const string &str){
		insert(root,str,0);
	}
	void insert(Node *cur, const string &str, int pos){
		if (pos >= (int)str.size()){
			cur->cnt++;
			return;
		}
		int c = str[pos]-'a';
		if (cur->go[c] == 0){
			cur->go[c] = new_Node();
		}
		insert(cur->go[c],str,pos+1);
	}

	void make_fail(){
		queue<Node*> que;
		que.push(root);
		while (!que.empty()){
			Node* fr=que.front();
			que.pop();
			for (int i=0; i<26; i++){
				if (fr->go[i]){
					Node *ptr = fr->fail;
					while (ptr && !ptr->go[i])
						ptr = ptr->fail;
					if (!ptr)
						fr->go[i]->fail = root;
					else
						fr->go[i]->fail = ptr->go[i];
					que.push(fr->go[i]);
				}
			}
		}
	}
};
\end{lstlisting}

\subsection{Z value}
\begin{lstlisting}
char s[MAXLEN];
int len,z[MAXLEN];
void Z_value() {
	int i,j,left,right;
	left=right=0; z[0]=len;
	for(i=1;i<len;i++) {
		j=max(min(z[i-left],right-i),0);
		for(;i+j<len&&s[i+j]==s[j];j++);
		z[i]=j;
		if(i+z[i]>right) {
			right=i+z[i];
			left=i;
		}
	}
}
\end{lstlisting}
\subsection{Suffix Automaton}
\begin{lstlisting}
class SAM{ //SuffixAutomaton
public:
	class State{
	public:
		State *par, *go[26];
		int val;
		State (int _val) : 
				par(0), val(_val){
			MSET(go,0);
		}
	};
	State *root, *tail;
	
	void init(const string &str){
		root = tail = new State(0);
		for (int i=0; i<SZ(str); i++)
			extend(str[i]-'a');
	}
	void extend(int w){
		State *p = tail, *np = new State(p->val+1);
		for ( ; p && p->go[w]==0; p=p->par)
			p->go[w] = np;
		if (p == 0){
			np->par = root;
		} else {
			if (p->go[w]->val == p->val+1){
				np->par = p->go[w];
			} else {
				State *q = p->go[w], *r = new State(0);
				*r = *q;
				r->val = p->val+1;
				q->par = np->par = r;
				for ( ; p && p->go[w]==q; p=p->par)
					p->go[w] = r;
			}
		}
		tail = np;
	}
};
\end{lstlisting}
\newpage
\section{Problems}
\subsection {Qtree IV}
\begin{lstlisting}
const int MX = 100005;
const int INF = 1029384756;

int N,fa[MX],faW[MX],sz[MX],belong[MX],color[MX],at[MX];
int fr,bk,que[MX];
vector<PII> E[MX];
multiset<int> D[MX];
multiset<int> ans;

struct Chain{
	int n;
	vector<int> V;
	struct Node{
		int mxL, mxR, mx;
	};
	Node *tree;
	int *d;

	void init(){
		n = V.size();
		for (int i=0; i<n; i++)
			at[V[i]] = i;
		d = new int[n];
		for (int i=1; i<n; i++)
			d[i] = d[i-1] + faW[V[i-1]];
		tree = new Node[4*n];
	}
	int max3(int a, int b, int c){
		return max(a,max(b,c));
	}
	void pushUp(int L, int R, int id){
		int M = (L+R)/2;
		int lc = id*2+1;
		int rc = id*2+2;
		tree[id].mxL = max3(-INF, tree[lc].mxL, d[M+1]-d[L]+tree[rc].mxL);
		tree[id].mxR = max3(-INF, tree[rc].mxR, d[R]-d[M]+tree[lc].mxR);
		tree[id].mx = max3(tree[lc].mx, tree[rc].mx, tree[lc].mxR + d[M+1]-d[M] + tree[rc].mxL);
	}
	void build_tree(int L, int R, int id){
		if (L == R){
			multiset<int>::reverse_iterator ptr=D[V[L]].rbegin();
			tree[id].mxL = tree[id].mxR = tree[id].mx = *ptr;
			ptr++;
			tree[id].mx = max(-INF,tree[id].mx+(*ptr));
			return ;
		}
		int M = (L+R)/2;
		build_tree(L,M,id*2+1);
		build_tree(M+1,R,id*2+2);
		pushUp(L,R,id);
	}
	void update_tree(int L, int R, int fn, int id){
		if (L == R){
			multiset<int>::reverse_iterator ptr=D[V[L]].rbegin();
			tree[id].mxL = tree[id].mxR = tree[id].mx = *ptr;
			ptr++;
			tree[id].mx = max(-INF,tree[id].mx+(*ptr));
			return ;
		}
		int M=(L+R)/2;
		if (fn <= M) update_tree(L,M,fn,id*2+1);
		else update_tree(M+1,R,fn,id*2+2);
		pushUp(L,R,id);
	}
	int update(int x){
		int u=V.back();
		int p=fa[u];
		if (p) D[p].erase(D[p].find(faW[u]+tree[0].mxR));
		ans.erase(ans.find(tree[0].mx));
		update_tree(0,n-1,at[x],0);
		ans.insert(tree[0].mx);
		if (p) D[p].insert(faW[u]+tree[0].mxR);
		return p;
	}

}chain[MX];

void DFS(int u){
	Chain &c = chain[belong[u]];
	c.init();
	for (int i=0,v; i<c.n; i++){
		u = c.V[i];
		FOR(it,E[u]){
			v = it->_F;
			if (fa[u] == v || (i && v == c.V[i-1])) continue;
			DFS(v);
			D[u].insert(chain[belong[v]].tree[0].mxR+it->_S);
		}
		D[u].insert(-INF);
		D[u].insert(-INF);
		D[u].insert(0);
	}
	c.build_tree(0,c.n-1,0);
	ans.insert(c.tree[0].mx);
}
int main(int argc, char** argv){
	scanf("%d", &N);
	for (int i=0,u,v,w; i<N-1; i++){
		scanf("%d%d%d", &u, &v, &w);
		E[u]._PB(_MP(v,w));
		E[v]._PB(_MP(u,w));
	}
	fr=bk=0;	que[bk++] = 1;
	while (fr < bk){
		int u=que[fr++],v;
		FOR(it,E[u]){
			v = it->_F;
			if (v == fa[u]) continue;
			que[bk++] = v;
			fa[v] = u;
			faW[v] = it->_S;
		}
	}
	for (int i=bk-1,u,v,pos; i>=0; i--){
		u = que[i];
		sz[u] = 1;
		pos = 0;
		FOR(it,E[u]){
			v = it->_F;
			if (v == fa[u]) continue;
			sz[u] += sz[v];
			if (sz[v] > sz[pos])
				pos=v;
		}
		if (pos == 0) belong[u] = u;
		else belong[u] = belong[pos];
		chain[belong[u]].V._PB(u);
	}
	DFS(1);
	int nq;
	scanf("%d", &nq);
	char cmd[10];
	while (nq--){
		scanf("%s", cmd);
		if (cmd[0] == 'C'){
			int x;
			scanf("%d", &x);
			if (color[x]){
				D[x].insert(0);
			} else {
				D[x].erase(D[x].find(0));
			}
			color[x] ^= 1;
			while (x){
				x = chain[belong[x]].update(x);
			}
		} else {
			if (*ans.rbegin() != -INF){
				printf("%d\n", max(0,*ans.rbegin()));
			} else {
				puts("They have disappeared.");
			}
		}
	}
	return 0;
}
\end{lstlisting}
\subsection{Find the maximun tangent (x,y is increasing)}
\begin{lstlisting}
#include <stdio.h>
typedef long long LL;
const int MAXN = 100010;
struct Coord{
	LL x, y;
	Coord operator - (Coord ag) const{
		Coord res;
		res.x = x - ag.x;
		res.y = y - ag.y;
		return res;
	}
}sum[MAXN], pnt[MAXN], ans, calc;

inline bool cross(Coord a, Coord b, Coord c){
	return (c.y - a.y) * (c.x - b.x) > (c.x - a.x) * (c.y - b.y);
}

int main(){
	int n, l, np, st, ed, now;
	scanf("%d %d\n", &n, &l);
	sum[0].x = sum[0].y = np = st = ed = 0;
	for (int i = 1, v; i <= n; i++){
		scanf("%d", &v);
		sum[i].y = sum[i - 1].y + v;
		sum[i].x = i;
	}
	ans.x = now = 1;
	ans.y = -1;
	for (int i = 0; i <= n - l; i++){
		while (np > 1 && cross(pnt[np - 2], pnt[np - 1], sum[i]))
			np--;
		if (np < now && np != 0) now = np;
		pnt[np++] = sum[i];
		while (now < np && !cross(pnt[now - 1], pnt[now], sum[i + l]))
			now++;
		calc = sum[i + l] - pnt[now - 1];
		if (ans.y * calc.x < ans.x * calc.y){
			ans = calc;
			st = pnt[now - 1].x;
			ed = i + l;
		}
	}
	double res = (sum[ed].y-sum[st].y)/(sum[ed].x-sum[st].x);
	printf("%f\n", res);
	return 0;
}
\end{lstlisting}

\subsection{Flow Problem}
\begin{lstlisting}
const int MAXN = 64;
const int INF = 1029384756;

int N;
int s1, s2, t1, t2, d1, d2, S, T;
int edge[MAXN][MAXN];
int cap[MAXN][MAXN];

int h[MAXN], gap[MAXN];
bool vis[MAXN];

int isap(int v, int f)
{
    if(v == T)return f;

    if(vis[v])return 0;
    vis[v] = true;

    for(int i=0; i<N+2; i++)
    {
        if(cap[v][i] <= 0)continue;
        if(h[i] != h[v] - 1)continue;
        int res = isap(i, min(cap[v][i], f));
        if(res > 0)
        {
            cap[v][i] -= res;
            cap[i][v] += res;
            return res;
        }
    }

    gap[h[v]]--;
    if(gap[h[v]] <= 0)h[S] = N + 4;
    h[v]++;
    gap[h[v]]++;

    return 0;
}

int get_flow()
{
    for(int i=0; i<MAXN; i++)
    {
        h[i] = gap[i] = 0;
    }
    gap[0] = N + 2;

    int flow = 0;

    while(h[S] <= N + 3)
    {
        for(int i=0; i<N+2; i++)
        {
            vis[i] = false;
        }

        int df = isap(S, INF);
        flow += df;
    }

    return flow;
}

int main()
{
    ios_base::sync_with_stdio(0);

    int TT;
    cin>>TT;
    while(TT--)
    {
        cin>>N;
        cin>>s1>>t1>>d1>>s2>>t2>>d2;

        for(int i=0; i<MAXN; i++)
        {
            for(int j=0; j<MAXN; j++)
            {
                edge[i][j] = 0;
            }
        }

        for(int i=0; i<N; i++)
        {
            string s;
            cin>>s;
            for(int j=0; j<N; j++)
            {
                if(s[j] == 'X')edge[i][j] = 0;
                else if(s[j] == 'O')edge[i][j] = 1;
                else if(s[j] == 'N')edge[i][j] = INF;
            }
        }

        int ans = 0;

        S = N;
        T = N + 1;

        //first
        for(int i=0; i<MAXN; i++)
        {
            for(int j=0; j<MAXN; j++)
            {
                cap[i][j] = edge[i][j];
            }
        }

        cap[S][s1] = cap[t1][T] = d1;
        cap[S][s2] = cap[t2][T] = d2;

        ans = get_flow();

        //second
        for(int i=0; i<MAXN; i++)
        {
            for(int j=0; j<MAXN; j++)
            {
                cap[i][j] = edge[i][j];
            }
        }

        cap[S][s1] = cap[t1][T] = d1;
        cap[S][t2] = cap[s2][T] = d2;

        ans = min(ans, get_flow());

        cout<<(ans == d1 + d2 ? "Yes" : "No")<<endl;
    }

    return 0;
}
\end{lstlisting}

\section{+1ironwood's code}
\subsection{KDTreeAndNearestPoint}
\begin{lstlisting}
#define INF 1100000000
class NODE{ public:
	int x,y,x1,x2,y1,y2;
	int i,f;
	NODE *L,*R;
};
inline long long dis(NODE& a,NODE& b){
	long long dx=a.x-b.x;
	long long dy=a.y-b.y;
	return dx*dx+dy*dy;
}
NODE node[100000];
bool cmpx(const NODE& a,const NODE& b){ return a.x<b.x; }
bool cmpy(const NODE& a,const NODE& b){ return a.y<b.y; }
NODE* KDTree(int L,int R,int dep){
	if(L>R) return 0;
	int M=(L+R)/2;
	if(dep%2==0){
		nth_element(node+L,node+M,node+R+1,cmpx);
		node[M].f=0;
	}else{
		nth_element(node+L,node+M,node+R+1,cmpy);
		node[M].f=1;
	}
	node[M].x1=node[M].x2=node[M].x;
	node[M].y1=node[M].y2=node[M].y;
	node[M].L=KDTree(L,M-1,dep+1);
	if(node[M].L){
		node[M].x1=min(node[M].x1,node[M].L->x1);
		node[M].x2=max(node[M].x2,node[M].L->x2);
		node[M].y1=min(node[M].y1,node[M].L->y1);
		node[M].y2=max(node[M].y2,node[M].L->y2);
	}
	node[M].R=KDTree(M+1,R,dep+1);
	if(node[M].R){
		node[M].x1=min(node[M].x1,node[M].R->x1);
		node[M].x2=max(node[M].x2,node[M].R->x2);
		node[M].y1=min(node[M].y1,node[M].R->y1);
		node[M].y2=max(node[M].y2,node[M].R->y2);
	}
	return node+M;
}
inline int touch(NODE* r,int x,int y,long long d){
	long long d2;
	d2 = (long long)(sqrt(d)+1);
	if(x<r->x1-d2 || x>r->x2+d2 || y<r->y1-d2 || y>r->y2+d2)
		return 0;
	return 1;
}
void nearest(NODE* r,int z,long long &md){
	if(!r || !touch(r,node[z].x,node[z].y,md)) return;
	long long d;
	if(node[z].i!=r->i){
		d=dis(*r,node[z]);
		if(d<md) md=d;
	}
	if(r->f==0){
		if(node[z].x<r->x){
			nearest(r->L,z,md);
			nearest(r->R,z,md);
		}else{
			nearest(r->R,z,md);
			nearest(r->L,z,md);
		}
	}else{
		if(node[z].y<r->y){
			nearest(r->L,z,md);
			nearest(r->R,z,md);
		}else{
			nearest(r->R,z,md);
			nearest(r->L,z,md);
		}
	}
}
int main(){
	int TT,n,i;
	long long d;
	NODE* root;
	scanf("%d",&TT);
	while(TT--){
		scanf("%d",&n);
		for(i=0;i<n;i++){
			scanf("%d %d",&node[i].x,&node[i].y);
			node[i].i=i;
		}
		root=KDTree(0,n-1,0);
		for(i=0;i<n;i++){
			d=9000000000000000000LL;
			nearest(root,i,d);
			ans[node[i].i]=d;
		}
	}
}
\end{lstlisting}
\subsection{MinkowskiSum}
\begin{lstlisting}
/* convex hull Minkowski Sum*/
#define INF 100000000000000LL
class PT{ public:
	long long x,y;
	int POS(){
		if(y==0) return x>0?0:1;
		return y>0?0:1;
	}
};
PT pt[300000],qt[300000],rt[300000];
long long Lx,Rx;
int dn,un;
inline bool cmp(PT a,PT b){
	int pa=a.POS(),pb=b.POS();
	if(pa==pb) return (a^b)>0;
	return pa<pb;
}
int minkowskiSum(int n,int m){
	int i,j,r,p,q,fi,fj;
	for(i=1,p=0;i<n;i++){
		if(pt[i].y<pt[p].y || (pt[i].y==pt[p].y && pt[i].x<
					pt[p].x)) p=i; }
	for(i=1,q=0;i<m;i++){
		if(qt[i].y<qt[q].y || (qt[i].y==qt[q].y && qt[i].x<
					qt[q].x)) q=i; }
	rt[0]=pt[p]+qt[q];
	r=1; i=p; j=q; fi=fj=0;
	while(1){
		if((fj&&j==q) || ((!fi||i!=p) && cmp(pt[(p+1)%n]-pt[
						p],qt[(q+1)%m]-qt[q]))){
			rt[r]=rt[r-1]+pt[(p+1)%n]-pt[p];
			p=(p+1)%n;
			fi=1;
		}else{
			rt[r]=rt[r-1]+qt[(q+1)%m]-qt[q];
			q=(q+1)%m;
			fj=1;
		}
		if(r<=1 || ((rt[r]-rt[r-1])^(rt[r-1]-rt[r-2]))!=0) r
			++;
		else rt[r-1]=rt[r];
		if(i==p && j==q) break;
	}
	return r-1;
}
void initInConvex(int n){
	int i,p,q;
	long long Ly,Ry;
	Lx=INF; Rx=-INF;
	for(i=0;i<n;i++){
		if(pt[i].x<Lx) Lx=pt[i].x;
		if(pt[i].x>Rx) Rx=pt[i].x;
	}
	Ly=Ry=INF;
	for(i=0;i<n;i++){
		if(pt[i].x==Lx && pt[i].y<Ly){ Ly=pt[i].y; p=i; }
		if(pt[i].x==Rx && pt[i].y<Ry){ Ry=pt[i].y; q=i; }
	}
	for(dn=0,i=p;i!=q;i=(i+1)%n){ qt[dn++]=pt[i]; }
	qt[dn]=pt[q]; Ly=Ry=-INF;
	for(i=0;i<n;i++){
		if(pt[i].x==Lx && pt[i].y>Ly){ Ly=pt[i].y; p=i; }
		if(pt[i].x==Rx && pt[i].y>Ry){ Ry=pt[i].y; q=i; }
	}
	for(un=0,i=p;i!=q;i=(i+n-1)%n){ rt[un++]=pt[i]; }
	rt[un]=pt[q];
}
inline int inConvex(PT p){
	int L,R,M;
	if(p.x<Lx || p.x>Rx) return 0;
	L=0;R=dn;
	while(L<R-1){ M=(L+R)/2;
		if(p.x<qt[M].x) R=M; else L=M; }
		if(tri(qt[L],qt[R],p)<0) return 0;
		L=0;R=un;
		while(L<R-1){ M=(L+R)/2;
			if(p.x<rt[M].x) R=M; else L=M; }
			if(tri(rt[L],rt[R],p)>0) return 0;
			return 1;
}
int main(){
	int n,m,i;
	PT p;
	scanf("%d",&n);
	for(i=0;i<n;i++) scanf("%I64d %I64d",&pt[i].x,&pt[i].y);
	scanf("%d",&m);
	for(i=0;i<m;i++) scanf("%I64d %I64d",&qt[i].x,&qt[i].y);
	n=minkowskiSum(n,m);
	for(i=0;i<n;i++) pt[i]=rt[i];
	scanf("%d",&m);
	for(i=0;i<m;i++) scanf("%I64d %I64d",&qt[i].x,&qt[i].y);
	n=minkowskiSum(n,m);
	for(i=0;i<n;i++) pt[i]=rt[i];
	initInConvex(n);
	scanf("%d",&m);
	for(i=0;i<m;i++){
		scanf("%I64d %I64d",&p.x,&p.y);
		p.x*=3; p.y*=3;
		puts(inConvex(p)?"YES":"NO");
	}
}
\end{lstlisting}
\subsection{MinimumMeanCycle}
\begin{lstlisting}
/* minimum mean cycle */
class Edge { public:
	int v,u;
	double c;
};
int n,m;
Edge e[MAXEDGE];
double d[MAXNUM][MAXNUM];
inline void relax(double &x,double val) { if(val<x) x=val; }
inline void bellman_ford() {
	int i,j;
	for(j=0;j<n;j++) d[0][j]=0.0;
	for(i=0;i<n;i++) {
		for(j=0;j<n;j++) d[i+1][j]=inf;
		for(j=0;j<m;j++)
			if(d[i][e[j].v]<inf-eps) relax(d[i+1][e[j].u],d[i][
					e[j].v]+e[j].c);
	}
}
inline double karp_mmc() {
	// returns inf if no cycle, mmc otherwise
	int i,k; double mmc=inf,avg;
	bellman_ford();
	for(i=0;i<n;i++) {
		avg=0.0;
		for(k=0;k<n;k++) {
			if(d[n][i]<inf-eps) avg=max(avg,(d[n][i]-d[k][i])/(
						n-k));
			else avg=max(avg,inf);
		}
		mmc=min(mmc,avg);
	}
	return mmc;
}
\end{lstlisting}

\subsection{PolynomialGenerator}
\begin{lstlisting}
class PolynomialGenerator {
	/* for a nth-order polynomial f(x), *
	 * given f(0), f(1), ..., f(n) *
	 * express f(x) as sigma_i{c_i*C(x,i)} */
	public:
		int n;
		vector<long long> coef;
		// initialize and calculate f(x), vector _fx should be
		filled with f(0) to f(n)
			PolynomialGenerator(int _n,vector<long long> _fx):n(_n
					),coef(_fx) {
				for(int i=0;i<n;i++)
					for(int j=n;j>i;j--)
						coef[j]-=coef[j-1];
			}
		// evaluate f(x), runs in O(n)
		long long eval(int x) {
			long long m=1,ret=0;
			for(int i=0;i<=n;i++) {
				ret+=coef[i]*m;
				m=m*(x-i)/(i+1);
			}
			return ret;
		}
};
\end{lstlisting}

\subsection{SwGeneralGraphMaxMatching}
\begin{lstlisting}
#define N 256 // max vertex num
class Graph { public:
	// n,g[i][j]=0/1, match() => match: (i,mate[i]) (or mate[i]=-1)
	int n, mate[N];
	bool g[N][N], inQ[N], inBlo[N];
	queue<int> Q;
	int start, newBase, prev[N], base[N];
	int lca(int u, int v) {
		bool path[N] = { false };
		while(true) {
			u = base[u]; path[u] = true;
			if(u == start) break;
			u = prev[mate[u]];
		}
		while(true) {
			v = base[v];
			if(path[v]) break;
			v = prev[mate[v]];
		}
		return v;
	}
	void trace(int u) {
		while(base[u] != newBase) {
			int v = mate[u];
			inBlo[base[u]] = inBlo[base[v]] = true;
			u = prev[v];
			if(base[u] != newBase) prev[u] = v;
		}
	}
	void contract(int u, int v) {
		newBase = lca(u, v);
		memset(inBlo, false, sizeof(inBlo));
		trace(u); trace(v);
		if(base[u] != newBase) prev[u] = v;
		if(base[v] != newBase) prev[v] = u;
		for(int i = 0; i < n; i++)
			if(inBlo[base[i]]) {
				base[i] = newBase;
				if(!inQ[i]) { Q.push(i); inQ[i] = true; }
			}
	}
	bool search() {
		memset(inQ, false, sizeof(inQ));
		memset(prev, -1, sizeof(prev));
		for(int i = 0; i < n; i++) base[i] = i;
		while(!Q.empty()) Q.pop();
		Q.push(start); inQ[start] = true;
		while(!Q.empty()) {
			int u = Q.front(); Q.pop();
			for(int i = 0; i < n; i++)
				if(g[u][i] && base[u] != base[i] && mate[u] != i){
					if(i == start || (mate[i] >= 0 && prev[mate[i]] >= 0)) contract(u, i);
					else if(prev[i] < 0) {
						prev[i] = u;
						if(mate[i] != -1) { Q.push(mate[i]); inQ[mate[i]] = true; }
						else { augment(i); return true; }
					}
				}
		}
		return false;
	}
	void augment(int u) {
		while(u >= 0) {
			int v = prev[u], w = mate[v];
			mate[v] = u; mate[u] = v; u = w;
		}
	}
	int match() {
		memset(mate, -1, sizeof(mate));
		int mth = 0;
		for(int i = 0; i < n; i++) {
			if(mate[i] >= 0) continue;
			start = i;
			if(search()) mth++;
		}
		return mth;
	}
};
\end{lstlisting}
\subsection{stoer-wagner-nm}
\begin{lstlisting}
// {{{ StoerWagner
const int inf=1000000000;
// should be larger than max.possible mincut
class StoerWagner {
	public:
		int n,mc; // node id in [0,n-1]
		vector<int> adj[MAXN];
		int cost[MAXN][MAXN];
		int cs[MAXN];
		bool merged[MAXN],sel[MAXN];
		// --8<-- include only if cut is explicitly needed
			DisjointSet djs;
		vector<int> cut;
		//--8<--------------------------------------------
			StoerWagner(int _n):n(_n),mc(inf),djs(_n) {
				for(int i=0;i<n;i++)
					merged[i]=0;
				for(int i=0;i<n;i++)
					for(int j=0;j<n;j++)
						cost[i][j]=cost[j][i]=0;
			}
		void append(int v,int u,int c) {
			if(v==u) return;
			if(!cost[v][u]&&c) {
				adj[v].PB(u);
				adj[u].PB(v);
			}
			cost[v][u]+=c;
			cost[u][v]+=c;
		}
		void merge(int v,int u) {
			merged[u]=1;
			for(int i=0;i<n;i++)
				append(v,i,cost[u][i]);
			// --8<-- include only if cut is explicitly needed
				djs.merge(v,u);
			//--8<--------------------------------------------
		}
		void phase() {
			priority_queue<pii> pq;
			for(int v=0;v<n;v++) {
				if(merged[v]) continue;
				cs[v]=0;
				sel[v]=0;
				pq.push(MP(0,v));
			}
			int v,s,pv;
			while(pq.size()) {
				if(cs[pq.top().S]>pq.top().F) {
					pq.pop();
					continue;
				}
				pv=v;
				v=pq.top().S;
				s=pq.top().F;
				pq.pop();
				sel[v]=1;
				for(int i=0;i<adj[v].size();i++) {
					int u=adj[v][i];
					if(merged[u]||sel[u]) continue;
					cs[u]+=cost[v][u];
					pq.push(MP(cs[u],u));
				}
			}
			if(s<mc) {
				mc=s;
				// --8<-- include only if cut is explicitly
				needed ------
					cut.clear();
				for(int i=0;i<n;i++)
					if(djs.getrep(i)==djs.getrep(v)) cut.PB(i);
				//--8<----------------------------------------
			}
			merge(v,pv);
		}
		int mincut() {
			if(mc==inf) {
				for(int t=0;t<n-1;t++)
					phase();
			}
			return mc;
		}
		// --8<-- include only if cut is explicitly needed
		------
			vector<int> getcut() { // return one side of the cut
				mincut();
				return cut;
			}
		//--8<--------------------------------------------
};
// }}}
\end{lstlisting}

\end{document}
